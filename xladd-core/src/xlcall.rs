#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]

use libc::{c_int, c_long, c_ushort, c_void, c_uchar, c_short, c_uint, c_char};

//  Code originally generated by rust-bindgen from the Excel SDK C headers.
//  Renamed generically-named types to match xlcall.h
//  Removed the Excel SDK C declarations not required for this library
//  Removed test code generated by rust-bindgen. These layout verification tests ensure the Rust
//  struct definitions match the original C struct layouts exactly. The tests were to verify that:
//   1. Struct sizes match between C and Rust (size_of)
//   2. Memory alignment is correct (align_of)
//   3. Field offsets are identical (field offset calculations)
//  Battled to get the tests to work, for a variety of reasons.
//
//  |---------------------|------------------------------|----------------------------------------|
//  |  Mappings between the Rust types and the C structures in xlcall.h                           |
//  |---------------------|------------------------------|----------------------------------------|
//  | Rust Name           |C Structure in xlcall.h       |Purpose                                 |
//  |---------------------|------------------------------|----------------------------------------|
//  | Xloper12Value       |Anonymous union in XLOPER12   |Contains the actual data for Excel 2007+|
//  | Xloper12SRef        |sref struct in union          |Single cell/range reference             |
//  | Xloper12MRef        |mref struct in union          |Multiple area reference                 |
//  | Xloper12Array       |array struct in union         |Array of values                         |
//  | Xloper12Flow        |flow struct in union          |XLM macro flow control                  |
//  | Xloper12BigData     |bigdata struct in union       |Large binary data                       |
//  |---------------------|------------------------------|----------------------------------------|

pub const xlerrNull: u32 = 0;
pub const xltypeNum: u32 = 1;
pub const xltypeStr: u32 = 2;
pub const xltypeBool: u32 = 4;
pub const xlerrDiv0: u32 = 7;
pub const xltypeRef: u32 = 8;
pub const xlerrValue: u32 = 15;
pub const xltypeErr: u32 = 16;
pub const xlerrRef: u32 = 23;
pub const xlerrName: u32 = 29;
pub const xlretFailed: u32 = 32;
pub const xlerrNum: u32 = 36;
pub const xlerrNA: u32 = 42;
pub const xlerrGettingData: u32 = 43;
pub const xltypeMulti: u32 = 64;
pub const xltypeMissing: u32 = 128;
pub const xlfRegister: u32 = 149;
pub const xltypeNil: u32 = 256;
pub const xltypeSRef: u32 = 1024;
pub const xltypeInt: u32 = 2048;
pub const xlbitXLFree: u32 = 4096;
pub const xlbitDLLFree: u32 = 16384;
pub const xlGetName: u32 = 16393;
pub const xlFree: u32 = 16384;

pub const xltypeMask: u32 = !(xlbitDLLFree | xlbitXLFree);

pub type INT32 = c_int;
pub type WCHAR = c_ushort;
pub type BYTE = c_uchar;
pub type WORD = c_ushort;
pub type DWORD = c_uint;
pub type LONG = c_long;
pub type DWORD_PTR = *mut DWORD;
pub type LPSTR = *mut c_char;
pub type VOID = c_void;
pub type HANDLE = *mut c_void;
pub type HWND = *mut c_void;

pub type BOOL = INT32;
pub type XCHAR = WCHAR;
pub type RW = INT32;
pub type COL = INT32;
pub type IDSHEET = DWORD_PTR;

// #[repr(C)]
// #[derive(Debug, Copy, Clone)]
// pub struct xlref {
//     pub rwFirst: WORD,
//     pub rwLast: WORD,
//     pub colFirst: BYTE,
//     pub colLast: BYTE,
// }
// pub type XLREF = xlref;
// pub type LPXLREF = *mut xlref;

// #[repr(C)]
// #[derive(Debug, Copy, Clone)]
// pub struct xlmref {
//     pub count: WORD,
//     pub reftbl: [XLREF; 1usize],
// }
// pub type XLMREF = xlmref;
// pub type LPXLMREF = *mut xlmref;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xlref12 {
    pub rwFirst: RW,
    pub rwLast: RW,
    pub colFirst: COL,
    pub colLast: COL,
}
pub type XLREF12 = xlref12;
pub type LPXLREF12 = *mut xlref12;

impl xlref12 {
    /// Get dimensions as (columns, rows)
    pub fn dim(&self) -> (usize, usize) {
        let rows = 1 + (self.rwLast - self.rwFirst) as usize;
        let cols = 1 + (self.colLast - self.colFirst) as usize;
        (cols, rows)
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xlmref12 {
    pub count: WORD,
    pub reftbl: [XLREF12; 1usize],
}
pub type XLMREF12 = xlmref12;
pub type LPXLMREF12 = *mut xlmref12;

// #[repr(C)]
// #[derive(Debug, Copy, Clone)]
// pub struct XloperSRef {
//     pub count: WORD,
//     pub ref_: XLREF,
// }

// #[repr(C)]
// #[derive(Debug, Copy, Clone)]
// pub struct XloperMRef {
//     pub lpmref: *mut XLMREF,
//     pub idSheet: IDSHEET,
// }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct XloperFlow {
    pub valflow: XloperFlowValue,
    pub rw: WORD,
    pub col: BYTE,
    pub xlflow: BYTE,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union XloperFlowValue {
    pub level: c_short,
    pub tbctrl: c_short,
    pub idSheet: IDSHEET,
    _bindgen_union_align: u64,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct XloperBigData {
    pub h: XloperBigDataHandle,
    pub cbData: c_long,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union XloperBigDataHandle {
    pub lpbData: *mut BYTE,
    pub hdata: HANDLE,
    _bindgen_union_align: u64,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct xloper12 {
    pub val: Xloper12Value,
    pub xltype: DWORD,
}
pub type XLOPER12 = xloper12;
pub type LPXLOPER12 = *mut xloper12;

#[repr(C)]
#[derive(Copy, Clone)]
pub union Xloper12Value {
    pub num: f64,
    pub str: *mut XCHAR,
    pub xbool: BOOL,
    pub err: c_int,
    pub w: c_int,
    pub sref: Xloper12SRef,
    pub mref: Xloper12MRef,
    pub array: Xloper12Array,
    pub flow: Xloper12Flow,
    pub bigdata: Xloper12BigData,
    _bindgen_union_align: [u64; 3usize],
}

impl Xloper12Value {
    /// Safely get number if this is a number type
    pub fn as_num(&self, xltype: u32) -> Option<f64> {
        if xltype & xltypeMask == xltypeNum {
            Some(unsafe { self.num })
        } else {
            None
        }
    }
    
    /// Safely get integer if this is an integer type  
    pub fn as_int(&self, xltype: u32) -> Option<i32> {
        if xltype & xltypeMask == xltypeInt {
            Some(unsafe { self.w })
        } else {
            None
        }
    }
    
    /// Safely get boolean if this is a boolean type
    pub fn as_bool(&self, xltype: u32) -> Option<bool> {
        if xltype & xltypeMask == xltypeBool {
            Some(unsafe { self.xbool != 0 })
        } else {
            None
        }
    }
    
    /// Safely get error code if this is an error type
    pub fn as_err(&self, xltype: u32) -> Option<i32> {
        if xltype & xltypeMask == xltypeErr {
            Some(unsafe { self.err })
        } else {
            None
        }
    }
    
    /// Safely get string reference if this is a string type
    pub fn as_str_ptr(&self, xltype: u32) -> Option<*mut u16> {
        if xltype & xltypeMask == xltypeStr {
            Some(unsafe { self.str })
        } else {
            None
        }
    }
    
    /// Safely get array reference if this is an array type
    pub fn as_array(&self, xltype: u32) -> Option<&Xloper12Array> {
        if xltype & xltypeMask == xltypeMulti {
            Some(unsafe { &self.array })
        } else {
            None
        }
    }
    
    /// Safely get single reference if this is a single ref type
    pub fn as_sref(&self, xltype: u32) -> Option<&Xloper12SRef> {
        if xltype & xltypeSRef == xltypeSRef {
            Some(unsafe { &self.sref })
        } else {
            None
        }
    }
    
    /// Safely get multiple reference if this is a multi ref type
    pub fn as_mref(&self, xltype: u32) -> Option<&Xloper12MRef> {
        if xltype & xltypeRef == xltypeRef {
            Some(unsafe { &self.mref })
        } else {
            None
        }
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Xloper12SRef {
    pub count: WORD,
    pub ref_: XLREF12,
}

impl Xloper12SRef {
    /// Get dimensions safely
    pub fn dim(&self) -> (usize, usize) {
        self.ref_.dim()
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Xloper12MRef {
    pub lpmref: *mut XLMREF12,
    pub idSheet: IDSHEET,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Xloper12Array {
    pub lparray: *mut xloper12,
    pub rows: RW,
    pub columns: COL,
}

impl Xloper12Array {
    /// Get dimensions safely
    pub fn dim(&self) -> (usize, usize) {
        (self.columns as usize, self.rows as usize)
    }
    
    /// Get total number of elements
    pub fn len(&self) -> usize {
        (self.rows * self.columns) as usize
    }
    
    /// Safely get element at index
    pub fn get(&self, index: usize) -> Option<&xloper12> {
        if index < self.len() {
            unsafe { Some(&*self.lparray.add(index)) }
        } else {
            None
        }
    }
    
    /// Safely get element at (row, col)
    pub fn get_2d(&self, row: usize, col: usize) -> Option<&xloper12> {
        if row < self.rows as usize && col < self.columns as usize {
            let index = row * self.columns as usize + col;
            self.get(index)
        } else {
            None
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct Xloper12Flow {
    pub valflow: Xloper12FlowValue,
    pub rw: RW,
    pub col: COL,
    pub xlflow: BYTE,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union Xloper12FlowValue {
    pub level: c_int,
    pub tbctrl: c_int,
    pub idSheet: IDSHEET,
    _bindgen_union_align: u64,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct Xloper12BigData {
    pub h: Xloper12BigDataHandle,
    pub cbData: c_long,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union Xloper12BigDataHandle {
    pub lpbData: *mut BYTE,
    pub hdata: HANDLE,
    _bindgen_union_align: u64,
}


// The following code has been manually edited to correct the calling conventions, which
// were all "C".

unsafe extern "stdcall" {
    #[link_name = "\u{1}XLCALLVER"]
    pub fn XLCallVer() -> c_int;
}
unsafe extern "stdcall" {
    #[link_name = "\u{1}LPENHELPER"]
    pub fn LPenHelper(wCode: c_int, lpv: *mut VOID) -> c_long;
}
unsafe extern "cdecl" {
    #[link_name = "\u{1}_Excel12"]
    pub fn Excel12(
        xlfn: c_int,
        operRes: LPXLOPER12,
        count: c_int,
        ...
    ) -> c_int;
}
unsafe extern "stdcall" {
    #[link_name = "\u{1}EXCEL12V"]
    pub fn Excel12v(
        xlfn: c_int,
        operRes: LPXLOPER12,
        count: c_int,
        opers: *mut LPXLOPER12,
    ) -> c_int;
}
pub type PXL_HPC_ASYNC_CALLBACK = ::std::option::Option<
    unsafe extern "stdcall" fn(
        dwAsyncHandle: DWORD,
        operReturn: LPXLOPER12,
    ) -> c_int,
>;